diff --git a/include/libbb.h b/include/libbb.h
index d05ac29..4d7d6fe 100644
--- a/include/libbb.h
+++ b/include/libbb.h
@@ -65,6 +65,16 @@
 #if defined(ANDROID) || defined(__ANDROID__)
 # define endpwent() ((void)0)
 # define endgrent() ((void)0)
+struct timex;
+pid_t getsid(pid_t pid);
+int stime(const time_t *t);
+int sethostname(const char *name, size_t len);
+int adjtimex(struct timex *buf);
+int pivot_root(const char *new_root, const char *put_old);
+ssize_t readahead(int fd, off64_t offset, size_t count);
+# include <mntent.h>
+int addmntent (FILE *stream, const struct mntent *mnt);
+char *hasmntopt (const struct mntent *mnt, const char *opt);
 #endif
 #ifdef HAVE_MNTENT_H
 # include <mntent.h>
@@ -1844,7 +1854,7 @@ extern struct globals *const ptr_to_globals;
  * use bb_default_login_shell and following defines.
  * If you change LIBBB_DEFAULT_LOGIN_SHELL,
  * don't forget to change increment constant. */
-#define LIBBB_DEFAULT_LOGIN_SHELL  "-/bin/sh"
+#define LIBBB_DEFAULT_LOGIN_SHELL  "-/system/bin/sh"
 extern const char bb_default_login_shell[] ALIGN1;
 /* "/bin/sh" */
 #define DEFAULT_SHELL              (bb_default_login_shell+1)
diff --git a/init/init.c b/init/init.c
index 2040a59..485d8ba 100644
--- a/init/init.c
+++ b/init/init.c
@@ -1071,7 +1071,7 @@ int init_main(int argc UNUSED_PARAM, char **argv)
 	/* Make sure environs is set to something sane */
 	putenv((char *) "HOME=/");
 	putenv((char *) bb_PATH_root_path);
-	putenv((char *) "SHELL=/bin/sh");
+	putenv((char *) "SHELL=/system/bin/sh");
 	putenv((char *) "USER=root"); /* needed? why? */
 
 	if (argv[1])
diff --git a/libbb/Kbuild.src b/libbb/Kbuild.src
index 7fb6872..ff227b2 100644
--- a/libbb/Kbuild.src
+++ b/libbb/Kbuild.src
@@ -114,6 +114,10 @@ lib-y += xgethostbyname.o
 lib-y += xreadlink.o
 lib-y += xrealloc_vector.o
 
+# for android-busybox-ndk
+lib-y += mntent_r.o
+lib-y += missing_syscalls.o
+
 lib-$(CONFIG_PLATFORM_LINUX) += match_fstype.o
 
 lib-$(CONFIG_FEATURE_UTMP) += utmp.o
diff --git a/libbb/missing_syscalls.c b/libbb/missing_syscalls.c
index 0934128..5387fa3 100644
--- a/libbb/missing_syscalls.c
+++ b/libbb/missing_syscalls.c
@@ -40,6 +40,11 @@ int pivot_root(const char *new_root, const char *put_old)
 	return syscall(__NR_pivot_root, new_root, put_old);
 }
 
+ssize_t readahead(int fd, off64_t offset, size_t count)
+{
+	return syscall(__NR_readahead, fd, offset, count);
+}
+
 # if __ANDROID_API__ < 21
 int tcdrain(int fd)
 {
diff --git a/libbb/mntent_r.c b/libbb/mntent_r.c
new file mode 100644
index 0000000..4c5d120
--- /dev/null
+++ b/libbb/mntent_r.c
@@ -0,0 +1,291 @@
+/* Utilities for reading/writing fstab, mtab, etc.
+   Copyright (C) 1995-2000, 2001, 2002, 2003, 2006, 2010, 2011
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+// file extracted from patch 'Bionic Patch V1.0 (Vitaly Greck)':
+// https://busybox-android.googlecode.com/files/patch
+//
+// looks like its based on misc/mntent_r.c from glibc,
+// contains all fixes in current master (2012-03-19),
+// but is not source identical (mostly stuff removed)
+// using the upstream one fails to build
+
+
+#include <alloca.h>
+#include <mntent.h>
+#include <stdio.h>
+#include <string.h>
+#include <sys/types.h>
+
+int addmntent (FILE *stream, const struct mntent *mnt);
+char *hasmntopt (const struct mntent *mnt, const char *opt);
+
+
+/* Prepare to begin reading and/or writing mount table entries from the
+   beginning of FILE.  MODE is as for `fopen'.  */
+FILE *setmntent (const char *file, const char *mode)
+{
+  /* Extend the mode parameter with "c" to disable cancellation in the
+     I/O functions and "e" to set FD_CLOEXEC.  */
+  size_t modelen = strlen (mode);
+  char newmode[modelen + 3];
+  memcpy (newmode, mode, modelen);
+  memcpy (newmode + modelen, "ce", 3);
+  FILE *result = fopen (file, newmode);
+
+  return result;
+}
+
+
+/* Close a stream opened with `setmntent'.  */
+int endmntent (FILE *stream)
+{
+  if (stream)		/* SunOS 4.x allows for NULL stream */
+    fclose (stream);
+  return 1;		/* SunOS 4.x says to always return 1 */
+}
+
+
+/* Since the values in a line are separated by spaces, a name cannot
+   contain a space.  Therefore some programs encode spaces in names
+   by the strings "\040".  We undo the encoding when reading an entry.
+   The decoding happens in place.  */
+static char *
+decode_name (char *buf)
+{
+  char *rp = buf;
+  char *wp = buf;
+
+  do
+    if (rp[0] == '\\' && rp[1] == '0' && rp[2] == '4' && rp[3] == '0')
+      {
+	/* \040 is a SPACE.  */
+	*wp++ = ' ';
+	rp += 3;
+      }
+    else if (rp[0] == '\\' && rp[1] == '0' && rp[2] == '1' && rp[3] == '1')
+      {
+	/* \011 is a TAB.  */
+	*wp++ = '\t';
+	rp += 3;
+      }
+    else if (rp[0] == '\\' && rp[1] == '0' && rp[2] == '1' && rp[3] == '2')
+      {
+	/* \012 is a NEWLINE.  */
+	*wp++ = '\n';
+	rp += 3;
+      }
+    else if (rp[0] == '\\' && rp[1] == '\\')
+      {
+	/* We have to escape \\ to be able to represent all characters.  */
+	*wp++ = '\\';
+	rp += 1;
+      }
+    else if (rp[0] == '\\' && rp[1] == '1' && rp[2] == '3' && rp[3] == '4')
+      {
+	/* \134 is also \\.  */
+	*wp++ = '\\';
+	rp += 3;
+      }
+    else
+      *wp++ = *rp;
+  while (*rp++ != '\0');
+
+  return buf;
+}
+
+
+/* Read one mount table entry from STREAM.  Returns a pointer to storage
+   reused on the next call, or null for EOF or error (use feof/ferror to
+   check).  */
+struct mntent *getmntent_r (FILE *stream, struct mntent *mp, char *buffer, int bufsiz)
+{
+  char *cp;
+  char *head;
+
+  do
+    {
+      char *end_ptr;
+
+      if (fgets (buffer, bufsiz, stream) == NULL)
+	{
+	  return NULL;
+	}
+
+      end_ptr = strchr (buffer, '\n');
+      if (end_ptr != NULL)	/* chop newline */
+	*end_ptr = '\0';
+      else
+	{
+	  /* Not the whole line was read.  Do it now but forget it.  */
+	  char tmp[1024];
+	  while (fgets (tmp, sizeof tmp, stream) != NULL)
+	    if (strchr (tmp, '\n') != NULL)
+	      break;
+	}
+
+      head = buffer + strspn (buffer, " \t");
+      /* skip empty lines and comment lines:  */
+    }
+  while (head[0] == '\0' || head[0] == '#');
+
+  cp = strsep (&head, " \t");
+  mp->mnt_fsname = cp != NULL ? decode_name (cp) : (char *) "";
+  if (head)
+    head += strspn (head, " \t");
+  cp = strsep (&head, " \t");
+  mp->mnt_dir = cp != NULL ? decode_name (cp) : (char *) "";
+  if (head)
+    head += strspn (head, " \t");
+  cp = strsep (&head, " \t");
+  mp->mnt_type = cp != NULL ? decode_name (cp) : (char *) "";
+  if (head)
+    head += strspn (head, " \t");
+  cp = strsep (&head, " \t");
+  mp->mnt_opts = cp != NULL ? decode_name (cp) : (char *) "";
+  switch (head ? sscanf (head, " %d %d ", &mp->mnt_freq, &mp->mnt_passno) : 0)
+    {
+    case 0:
+      mp->mnt_freq = 0;
+    case 1:
+      mp->mnt_passno = 0;
+    case 2:
+      break;
+    }
+
+  return mp;
+}
+
+struct mntent *getmntent (FILE *stream)
+{
+  static struct mntent m;
+  static char *getmntent_buffer;
+
+  #define BUFFER_SIZE 4096
+  if (getmntent_buffer == NULL) {
+    getmntent_buffer = (char *) malloc (BUFFER_SIZE);
+  }
+
+  return getmntent_r (stream, &m, getmntent_buffer, BUFFER_SIZE);
+  #undef BUFFER_SIZE
+}
+
+
+/* We have to use an encoding for names if they contain spaces or tabs.
+   To be able to represent all characters we also have to escape the
+   backslash itself.  This "function" must be a macro since we use
+   `alloca'.  */
+#define encode_name(name) \
+  do {									      \
+    const char *rp = name;						      \
+									      \
+    while (*rp != '\0')							      \
+      if (*rp == ' ' || *rp == '\t' || *rp == '\n' || *rp == '\\')	      \
+	break;								      \
+      else								      \
+	++rp;								      \
+									      \
+    if (*rp != '\0')							      \
+      {									      \
+	/* In the worst case the length of the string can increase to	      \
+	   four times the current length.  */				      \
+	char *wp;							      \
+									      \
+	rp = name;							      \
+	name = wp = (char *) alloca (strlen (name) * 4 + 1);		      \
+									      \
+	do								      \
+	  if (*rp == ' ')						      \
+	    {								      \
+	      *wp++ = '\\';						      \
+	      *wp++ = '0';						      \
+	      *wp++ = '4';						      \
+	      *wp++ = '0';						      \
+	    }								      \
+	  else if (*rp == '\t')						      \
+	    {								      \
+	      *wp++ = '\\';						      \
+	      *wp++ = '0';						      \
+	      *wp++ = '1';						      \
+	      *wp++ = '1';						      \
+	    }								      \
+	  else if (*rp == '\n')						      \
+	    {								      \
+	      *wp++ = '\\';						      \
+	      *wp++ = '0';						      \
+	      *wp++ = '1';						      \
+	      *wp++ = '2';						      \
+	    }								      \
+	  else if (*rp == '\\')						      \
+	    {								      \
+	      *wp++ = '\\';						      \
+	      *wp++ = '\\';						      \
+	    }								      \
+	  else								      \
+	    *wp++ = *rp;						      \
+	while (*rp++ != '\0');						      \
+      }									      \
+  } while (0)
+
+
+/* Write the mount table entry described by MNT to STREAM.
+   Return zero on success, nonzero on failure.  */
+int addmntent (FILE *stream, const struct mntent *mnt)
+{
+  struct mntent mntcopy = *mnt;
+  if (fseek (stream, 0, SEEK_END))
+    return 1;
+
+  /* Encode spaces and tabs in the names.  */
+  encode_name (mntcopy.mnt_fsname);
+  encode_name (mntcopy.mnt_dir);
+  encode_name (mntcopy.mnt_type);
+  encode_name (mntcopy.mnt_opts);
+
+  return (fprintf (stream, "%s %s %s %s %d %d\n",
+		   mntcopy.mnt_fsname,
+		   mntcopy.mnt_dir,
+		   mntcopy.mnt_type,
+		   mntcopy.mnt_opts,
+		   mntcopy.mnt_freq,
+		   mntcopy.mnt_passno) < 0
+	  || fflush (stream) != 0);
+}
+
+
+/* Search MNT->mnt_opts for an option matching OPT.
+   Returns the address of the substring, or null if none found.  */
+char *hasmntopt (const struct mntent *mnt, const char *opt)
+{
+  const size_t optlen = strlen (opt);
+  char *rest = mnt->mnt_opts, *p;
+
+  while ((p = strstr (rest, opt)) != NULL)
+    {
+      if ((p == rest || p[-1] == ',')
+	  && (p[optlen] == '\0' || p[optlen] == '=' || p[optlen] == ','))
+	return p;
+
+      rest = strchr (p, ',');
+      if (rest == NULL)
+	break;
+      ++rest;
+    }
+
+  return NULL;
+}
diff --git a/shell/ash.c b/shell/ash.c
index b5a2d96..1d9ba4a 100644
--- a/shell/ash.c
+++ b/shell/ash.c
@@ -13125,6 +13125,7 @@ int ash_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int ash_main(int argc UNUSED_PARAM, char **argv)
 {
 	const char *shinit;
+	const char *hp;
 	volatile smallint state;
 	struct jmploc jmploc;
 	struct stackmark smark;
@@ -13185,22 +13186,13 @@ int ash_main(int argc UNUSED_PARAM, char **argv)
 	setstackmark(&smark);
 	procargs(argv);
 
-	if (argv[0] && argv[0][0] == '-')
-		isloginsh = 1;
-	if (isloginsh) {
-		const char *hp;
-
-		state = 1;
-		read_profile("/etc/profile");
+	isloginsh = 1;
+	state = 1;
+	read_profile("/system/etc/profile");
  state1:
-		state = 2;
-		hp = lookupvar("HOME");
-		if (hp) {
-			hp = concat_path_file(hp, ".profile");
-			read_profile(hp);
-			free((char*)hp);
-		}
-	}
+	state = 2;
+	if (!hp)
+		setvar("HISTFILE", "/data/ash_history", 0);
  state2:
 	state = 3;
 	if (
@@ -13230,15 +13222,10 @@ int ash_main(int argc UNUSED_PARAM, char **argv)
 	if (sflag || minusc == NULL) {
 #if MAX_HISTORY > 0 && ENABLE_FEATURE_EDITING_SAVEHISTORY
 		if (iflag) {
-			const char *hp = lookupvar("HISTFILE");
+			hp = lookupvar("HISTFILE");
 			if (!hp) {
-				hp = lookupvar("HOME");
-				if (hp) {
-					hp = concat_path_file(hp, ".ash_history");
-					setvar0("HISTFILE", hp);
-					free((char*)hp);
-					hp = lookupvar("HISTFILE");
-				}
+				setvar("HISTFILE", "/data/ash_history", 0);
+				hp = lookupvar("HISTFILE");
 			}
 			if (hp)
 				line_input_state->hist_file = hp;
