diff --git a/archival/libarchive/get_header_tar.c b/archival/libarchive/get_header_tar.c
index ac2be72..57e6eed 100644
--- a/archival/libarchive/get_header_tar.c
+++ b/archival/libarchive/get_header_tar.c
@@ -391,9 +391,9 @@ char FAST_FUNC get_header_tar(archive_handle_t *archive_handle)
 	}
  skip_ext_hdr:
 	{
-		off_t sz;
+		loff_t sz;
 		bb_error_msg("warning: skipping header '%c'", tar.typeflag);
-		sz = (file_header->size + 511) & ~(off_t)511;
+		sz = (file_header->size + 511) & ~(loff_t)511;
 		archive_handle->offset += sz;
 		sz >>= 9; /* sz /= 512 but w/o contortions for signed div */
 		while (sz--)
diff --git a/archival/tar.c b/archival/tar.c
index 23ac00e..423b4f8 100644
--- a/archival/tar.c
+++ b/archival/tar.c
@@ -259,9 +259,9 @@ static HardLinkInfo *findHardLinkInfo(HardLinkInfo *hlInfo, struct stat *statbuf
 /* Put an octal string into the specified buffer.
  * The number is zero padded and possibly null terminated.
  * Stores low-order bits only if whole value does not fit. */
-static void putOctal(char *cp, int len, off_t value)
+static void putOctal(char *cp, int len, loff_t value)
 {
-	char tempBuffer[sizeof(off_t)*3 + 1];
+	char tempBuffer[sizeof(loff_t)*3 + 1];
 	char *tempString = tempBuffer;
 	int width;
 
diff --git a/coreutils/dd.c b/coreutils/dd.c
index 0c0ea07..37224e3 100644
--- a/coreutils/dd.c
+++ b/coreutils/dd.c
@@ -90,6 +90,10 @@
 //usage:       "4+0 records in\n"
 //usage:       "4+0 records out\n"
 
+#ifndef _LARGEFILE64_SOURCE
+/* For lseek64 */
+# define _LARGEFILE64_SOURCE
+#endif
 #include "libbb.h"
 
 /* This is a NOEXEC applet. Be very careful! */
@@ -101,7 +105,7 @@ enum {
 };
 
 struct globals {
-	off_t out_full, out_part, in_full, in_part;
+	loff_t out_full, out_part, in_full, in_part;
 #if ENABLE_FEATURE_DD_THIRD_STATUS_LINE
 	unsigned long long total_bytes;
 	unsigned long long begin_time_us;
@@ -304,8 +308,8 @@ int dd_main(int argc UNUSED_PARAM, char **argv)
 	struct {
 		size_t oc;
 		ssize_t prev_read_size; /* for detecting swab failure */
-		off_t count;
-		off_t seek, skip;
+		loff_t count;
+		loff_t seek, skip;
 		const char *infile, *outfile;
 	} Z;
 #define oc      (Z.oc     )
@@ -445,7 +449,7 @@ int dd_main(int argc UNUSED_PARAM, char **argv)
 	}
 	if (skip) {
 		size_t blocksz = (G.flags & FLAG_SKIP_BYTES) ? 1 : ibs;
-		if (lseek(ifd, skip * blocksz, SEEK_CUR) < 0) {
+		if (lseek64(ifd, skip * blocksz, SEEK_CUR) < 0) {
 			do {
 				ssize_t n = safe_read(ifd, ibuf, blocksz);
 				if (n < 0)
@@ -456,7 +460,7 @@ int dd_main(int argc UNUSED_PARAM, char **argv)
 		}
 	}
 	if (seek) {
-		if (lseek(ofd, seek * obs, SEEK_CUR) < 0)
+		if (lseek64(ofd, seek * obs, SEEK_CUR) < 0)
 			goto die_outfile;
 	}
 
diff --git a/coreutils/ls.c b/coreutils/ls.c
index 20bd618..244b2ec 100644
--- a/coreutils/ls.c
+++ b/coreutils/ls.c
@@ -328,7 +328,7 @@ struct dnode {
 //
 	/* Same names as in struct stat, but with dn_ instead of st_ pfx: */
 	mode_t    dn_mode; /* obtained with lstat OR stat, depending on -L etc */
-	off_t     dn_size;
+	loff_t     dn_size;
 #if ENABLE_FEATURE_LS_TIMESTAMPS || ENABLE_FEATURE_LS_SORTFILES
 	time_t    dn_atime;
 	time_t    dn_mtime;
@@ -522,7 +522,7 @@ static NOINLINE unsigned display_single(const struct dnode *dn)
 		column += printf("%7llu ", (long long) dn->dn_ino);
 //TODO: -h should affect -s too:
 	if (G.all_fmt & LIST_BLOCKS)
-		column += printf("%6"OFF_FMT"u ", (off_t) (dn->dn_blocks >> 1));
+		column += printf("%6"OFF_FMT"u ", (loff_t) (dn->dn_blocks >> 1));
 	if (G.all_fmt & LIST_MODEBITS)
 		column += printf("%-10s ", (char *) bb_mode_string(dn->dn_mode));
 	if (G.all_fmt & LIST_NLINKS)
@@ -1003,7 +1003,7 @@ static struct dnode **scan_one_dir(const char *path, unsigned *nfiles_p)
  * number of units.
  */
 /* by Jorgen Overgaard (jorgen AT antistaten.se) */
-static off_t calculate_blocks(struct dnode **dn)
+static loff_t calculate_blocks(struct dnode **dn)
 {
 	uoff_t blocks = 1;
 	if (dn) {
diff --git a/coreutils/od_bloaty.c b/coreutils/od_bloaty.c
index f47f84b..079d9ea 100644
--- a/coreutils/od_bloaty.c
+++ b/coreutils/od_bloaty.c
@@ -185,12 +185,12 @@ struct globals {
 
 	/* Function that accepts an address and an optional following char,
 	   and prints the address and char to stdout.  */
-	void (*format_address)(off_t, char);
+	void (*format_address)(loff_t, char);
 
 	/* The difference between the old-style pseudo starting address and
 	   the number of bytes to skip.  */
 #if ENABLE_LONG_OPTS
-	off_t pseudo_offset;
+	loff_t pseudo_offset;
 # define G_pseudo_offset G.pseudo_offset
 #endif
 	/* When zero, MAX_BYTES_TO_FORMAT and END_OFFSET are ignored, and all
@@ -772,7 +772,7 @@ decode_format_string(const char *s)
    advance IN_STREAM.  */
 
 static void
-skip(off_t n_skip)
+skip(loff_t n_skip)
 {
 	if (n_skip == 0)
 		return;
@@ -834,10 +834,10 @@ skip(off_t n_skip)
 }
 
 
-typedef void FN_format_address(off_t address, char c);
+typedef void FN_format_address(loff_t address, char c);
 
 static void
-format_address_none(off_t address UNUSED_PARAM, char c UNUSED_PARAM)
+format_address_none(loff_t address UNUSED_PARAM, char c UNUSED_PARAM)
 {
 }
 
@@ -848,7 +848,7 @@ static char address_fmt[] ALIGN1 = "%0n"OFF_FMT"xc";
 #define address_pad_len_char address_fmt[2]
 
 static void
-format_address_std(off_t address, char c)
+format_address_std(loff_t address, char c)
 {
 	/* Corresponds to 'c' */
 	address_fmt[sizeof(address_fmt)-2] = c;
@@ -858,7 +858,7 @@ format_address_std(off_t address, char c)
 #if ENABLE_LONG_OPTS
 /* only used with --traditional */
 static void
-format_address_paren(off_t address, char c)
+format_address_paren(loff_t address, char c)
 {
 	putchar('(');
 	format_address_std(address, ')');
@@ -866,7 +866,7 @@ format_address_paren(off_t address, char c)
 }
 
 static void
-format_address_label(off_t address, char c)
+format_address_label(loff_t address, char c)
 {
 	format_address_std(address, ' ');
 	format_address_paren(address + G_pseudo_offset, c);
@@ -897,7 +897,7 @@ dump_hexl_mode_trailer(size_t n_bytes, const char *block)
    only when it has not been padded to length BYTES_PER_BLOCK.  */
 
 static void
-write_block(off_t current_offset, size_t n_bytes,
+write_block(loff_t current_offset, size_t n_bytes,
 		const char *prev_block, const char *curr_block)
 {
 	unsigned i;
@@ -986,7 +986,7 @@ get_lcm(void)
    read.  */
 
 static void
-dump(off_t current_offset, off_t end_offset)
+dump(loff_t current_offset, loff_t end_offset)
 {
 	char *block[2];
 	int idx;
@@ -1003,7 +1003,7 @@ dump(off_t current_offset, off_t end_offset)
 				n_bytes_read = 0;
 				break;
 			}
-			n_needed = MIN(end_offset - current_offset, (off_t) G.bytes_per_block);
+			n_needed = MIN(end_offset - current_offset, (loff_t) G.bytes_per_block);
 			read_block(n_needed, block[idx], &n_bytes_read);
 			if (n_bytes_read < G.bytes_per_block)
 				break;
@@ -1069,7 +1069,7 @@ dump(off_t current_offset, off_t end_offset)
    traditional version of od.  */
 
 static void
-dump_strings(off_t address, off_t end_offset)
+dump_strings(loff_t address, loff_t end_offset)
 {
 	unsigned bufsize = MAX(100, G.string_min);
 	unsigned char *buf = xmalloc(bufsize);
@@ -1141,7 +1141,7 @@ dump_strings(off_t address, off_t end_offset)
    leading '+' return nonzero and set *OFFSET to the offset it denotes.  */
 
 static int
-parse_old_offset(const char *s, off_t *offset)
+parse_old_offset(const char *s, loff_t *offset)
 {
 	static const struct suffix_mult Bb[] = {
 		{ "B", 1024 },
@@ -1196,11 +1196,11 @@ int od_main(int argc UNUSED_PARAM, char **argv)
 	unsigned opt;
 	int l_c_m;
 	/* The number of input bytes to skip before formatting and writing.  */
-	off_t n_bytes_to_skip = 0;
+	loff_t n_bytes_to_skip = 0;
 	/* The offset of the first byte after the last byte to be formatted.  */
-	off_t end_offset = 0;
+	loff_t end_offset = 0;
 	/* The maximum number of bytes that will be formatted.  */
-	off_t max_bytes_to_format = 0;
+	loff_t max_bytes_to_format = 0;
 
 	INIT_G();
 
@@ -1273,8 +1273,8 @@ int od_main(int argc UNUSED_PARAM, char **argv)
 #if ENABLE_LONG_OPTS
 	if (opt & OPT_traditional) {
 		if (argv[0]) {
-			off_t pseudo_start = -1;
-			off_t o1, o2;
+			loff_t pseudo_start = -1;
+			loff_t o1, o2;
 
 			if (!argv[1]) { /* one arg */
 				if (parse_old_offset(argv[0], &o1)) {
diff --git a/coreutils/truncate.c b/coreutils/truncate.c
index 8d845f2..923c778 100644
--- a/coreutils/truncate.c
+++ b/coreutils/truncate.c
@@ -43,7 +43,7 @@ int truncate_main(int argc UNUSED_PARAM, char **argv)
 	int flags = O_WRONLY | O_NONBLOCK;
 	int ret = EXIT_SUCCESS;
 	char *size_str;
-	off_t size;
+	loff_t size;
 
 	enum {
 		OPT_NOCREATE  = (1 << 0),
diff --git a/editors/cmp.c b/editors/cmp.c
index a4af6f4..29e7a81 100644
--- a/editors/cmp.c
+++ b/editors/cmp.c
@@ -45,7 +45,7 @@ int cmp_main(int argc UNUSED_PARAM, char **argv)
 {
 	FILE *fp1, *fp2, *outfile = stdout;
 	const char *filename1, *filename2 = "-";
-	off_t skip1 = 0, skip2 = 0, char_pos = 0;
+	loff_t skip1 = 0, skip2 = 0, char_pos = 0;
 	int line_pos = 1; /* Hopefully won't overflow... */
 	const char *fmt;
 	int c1, c2;
diff --git a/include/bb_archive.h b/include/bb_archive.h
index 10969b5..1873ea7 100644
--- a/include/bb_archive.h
+++ b/include/bb_archive.h
@@ -35,7 +35,7 @@ typedef struct file_header_t {
 	char *tar__uname;
 	char *tar__gname;
 #endif
-	off_t size;
+	loff_t size;
 	uid_t uid;
 	gid_t gid;
 	mode_t mode;
diff --git a/include/libbb.h b/include/libbb.h
index d05ac29..dd38a22 100644
--- a/include/libbb.h
+++ b/include/libbb.h
@@ -65,6 +65,16 @@
 #if defined(ANDROID) || defined(__ANDROID__)
 # define endpwent() ((void)0)
 # define endgrent() ((void)0)
+struct timex;
+pid_t getsid(pid_t pid);
+int stime(const time_t *t);
+int sethostname(const char *name, size_t len);
+int adjtimex(struct timex *buf);
+int pivot_root(const char *new_root, const char *put_old);
+ssize_t readahead(int fd, off64_t offset, size_t count);
+# include <mntent.h>
+int addmntent (FILE *stream, const struct mntent *mnt);
+char *hasmntopt (const struct mntent *mnt, const char *opt);
 #endif
 #ifdef HAVE_MNTENT_H
 # include <mntent.h>
@@ -277,12 +287,6 @@ typedef unsigned long uoff_t;
 #endif
 /* scary. better ideas? (but do *test* them first!) */
 #define OFF_T_MAX  ((off_t)~((off_t)1 << (sizeof(off_t)*8-1)))
-/* Users report bionic to use 32-bit off_t even if LARGEFILE support is requested.
- * We misdetected that. Don't let it build:
- */
-struct BUG_off_t_size_is_misdetected {
-	char BUG_off_t_size_is_misdetected[sizeof(off_t) == sizeof(uoff_t) ? 1 : -1];
-};
 
 /* Some useful definitions */
 #undef FALSE
@@ -394,12 +398,12 @@ extern int get_console_fd_or_die(void) FAST_FUNC;
 extern void console_make_active(int fd, const int vt_num) FAST_FUNC;
 extern char *find_block_device(const char *path) FAST_FUNC;
 /* bb_copyfd_XX print read/write errors and return -1 if they occur */
-extern off_t bb_copyfd_eof(int fd1, int fd2) FAST_FUNC;
-extern off_t bb_copyfd_size(int fd1, int fd2, off_t size) FAST_FUNC;
-extern void bb_copyfd_exact_size(int fd1, int fd2, off_t size) FAST_FUNC;
+extern loff_t bb_copyfd_eof(int fd1, int fd2) FAST_FUNC;
+extern loff_t bb_copyfd_size(int fd1, int fd2, loff_t size) FAST_FUNC;
+extern void bb_copyfd_exact_size(int fd1, int fd2, loff_t size) FAST_FUNC;
 /* "short" copy can be detected by return value < size */
 /* this helper yells "short read!" if param is not -1 */
-extern void complain_copyfd_and_die(off_t sz) NORETURN FAST_FUNC;
+extern void complain_copyfd_and_die(loff_t sz) NORETURN FAST_FUNC;
 
 extern char bb_process_escape_sequence(const char **ptr) FAST_FUNC;
 char* strcpy_and_process_escape_sequences(char *dst, const char *src) FAST_FUNC;
@@ -513,9 +517,9 @@ int open_or_warn_stdin(const char *pathname) FAST_FUNC;
 int xopen_stdin(const char *pathname) FAST_FUNC;
 void xrename(const char *oldpath, const char *newpath) FAST_FUNC;
 int rename_or_warn(const char *oldpath, const char *newpath) FAST_FUNC;
-off_t xlseek(int fd, off_t offset, int whence) FAST_FUNC;
+loff_t xlseek(int fd, loff_t offset, int whence) FAST_FUNC;
 int xmkstemp(char *template) FAST_FUNC;
-off_t fdlength(int fd) FAST_FUNC;
+loff_t fdlength(int fd) FAST_FUNC;
 
 uoff_t FAST_FUNC get_volume_size_in_bytes(int fd,
 		const char *override,
@@ -1844,7 +1848,7 @@ extern struct globals *const ptr_to_globals;
  * use bb_default_login_shell and following defines.
  * If you change LIBBB_DEFAULT_LOGIN_SHELL,
  * don't forget to change increment constant. */
-#define LIBBB_DEFAULT_LOGIN_SHELL  "-/bin/sh"
+#define LIBBB_DEFAULT_LOGIN_SHELL  "-/system/bin/sh"
 extern const char bb_default_login_shell[] ALIGN1;
 /* "/bin/sh" */
 #define DEFAULT_SHELL              (bb_default_login_shell+1)
diff --git a/init/init.c b/init/init.c
index 25bfaec..b27b79e 100644
--- a/init/init.c
+++ b/init/init.c
@@ -1086,7 +1086,7 @@ int init_main(int argc UNUSED_PARAM, char **argv)
 	/* Make sure environs is set to something sane */
 	putenv((char *) "HOME=/");
 	putenv((char *) bb_PATH_root_path);
-	putenv((char *) "SHELL=/bin/sh");
+	putenv((char *) "SHELL=/system/bin/sh");
 	putenv((char *) "USER=root"); /* needed? why? */
 
 	if (argv[1])
diff --git a/libbb/Kbuild.src b/libbb/Kbuild.src
index 7fb6872..ff227b2 100644
--- a/libbb/Kbuild.src
+++ b/libbb/Kbuild.src
@@ -114,6 +114,10 @@ lib-y += xgethostbyname.o
 lib-y += xreadlink.o
 lib-y += xrealloc_vector.o
 
+# for android-busybox-ndk
+lib-y += mntent_r.o
+lib-y += missing_syscalls.o
+
 lib-$(CONFIG_PLATFORM_LINUX) += match_fstype.o
 
 lib-$(CONFIG_FEATURE_UTMP) += utmp.o
diff --git a/libbb/copyfd.c b/libbb/copyfd.c
index 7e35319..d1fb9f5 100644
--- a/libbb/copyfd.c
+++ b/libbb/copyfd.c
@@ -27,10 +27,10 @@
  * size < 0 means "ignore write errors", used by tar --to-command
  * size = 0 means "copy till EOF"
  */
-static off_t bb_full_fd_action(int src_fd, int dst_fd, off_t size)
+static loff_t bb_full_fd_action(int src_fd, int dst_fd, loff_t size)
 {
 	int status = -1;
-	off_t total = 0;
+	loff_t total = 0;
 	bool continue_on_write_error = 0;
 	ssize_t sendfile_sz;
 #if CONFIG_FEATURE_COPYBUF_KB > 4
@@ -135,7 +135,7 @@ void FAST_FUNC complain_copyfd_and_die(off_t sz)
 }
 #endif
 
-off_t FAST_FUNC bb_copyfd_size(int fd1, int fd2, off_t size)
+loff_t FAST_FUNC bb_copyfd_size(int fd1, int fd2, loff_t size)
 {
 	if (size) {
 		return bb_full_fd_action(fd1, fd2, size);
@@ -143,9 +143,9 @@ off_t FAST_FUNC bb_copyfd_size(int fd1, int fd2, off_t size)
 	return 0;
 }
 
-void FAST_FUNC bb_copyfd_exact_size(int fd1, int fd2, off_t size)
+void FAST_FUNC bb_copyfd_exact_size(int fd1, int fd2, loff_t size)
 {
-	off_t sz = bb_copyfd_size(fd1, fd2, size);
+	loff_t sz = bb_copyfd_size(fd1, fd2, size);
 	if (sz == (size >= 0 ? size : -size))
 		return;
 	if (sz != -1)
@@ -154,7 +154,7 @@ void FAST_FUNC bb_copyfd_exact_size(int fd1, int fd2, off_t size)
 	xfunc_die();
 }
 
-off_t FAST_FUNC bb_copyfd_eof(int fd1, int fd2)
+loff_t FAST_FUNC bb_copyfd_eof(int fd1, int fd2)
 {
 	return bb_full_fd_action(fd1, fd2, 0);
 }
diff --git a/libbb/loop.c b/libbb/loop.c
index d30b378..3a37775 100644
--- a/libbb/loop.c
+++ b/libbb/loop.c
@@ -56,7 +56,7 @@ char* FAST_FUNC query_loop(const char *device)
 	fd = open(device, O_RDONLY);
 	if (fd >= 0) {
 		if (ioctl(fd, BB_LOOP_GET_STATUS, &loopinfo) == 0) {
-			dev = xasprintf("%"OFF_FMT"u %s", (off_t) loopinfo.lo_offset,
+			dev = xasprintf("%"OFF_FMT"u %s", (loff_t) loopinfo.lo_offset,
 					(char *)loopinfo.lo_file_name);
 		}
 		close(fd);
diff --git a/libbb/missing_syscalls.c b/libbb/missing_syscalls.c
index 0934128..5387fa3 100644
--- a/libbb/missing_syscalls.c
+++ b/libbb/missing_syscalls.c
@@ -40,6 +40,11 @@ int pivot_root(const char *new_root, const char *put_old)
 	return syscall(__NR_pivot_root, new_root, put_old);
 }
 
+ssize_t readahead(int fd, off64_t offset, size_t count)
+{
+	return syscall(__NR_readahead, fd, offset, count);
+}
+
 # if __ANDROID_API__ < 21
 int tcdrain(int fd)
 {
diff --git a/libbb/mntent_r.c b/libbb/mntent_r.c
new file mode 100644
index 0000000..ea98a69
--- /dev/null
+++ b/libbb/mntent_r.c
@@ -0,0 +1,292 @@
+/* Utilities for reading/writing fstab, mtab, etc.
+   Copyright (C) 1995-2000, 2001, 2002, 2003, 2006, 2010, 2011
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+// file extracted from patch 'Bionic Patch V1.0 (Vitaly Greck)':
+// https://busybox-android.googlecode.com/files/patch
+//
+// looks like its based on misc/mntent_r.c from glibc,
+// contains all fixes in current master (2012-03-19),
+// but is not source identical (mostly stuff removed)
+// using the upstream one fails to build
+
+
+#include <alloca.h>
+#include <mntent.h>
+#include <stdio.h>
+#include <string.h>
+#include <sys/types.h>
+
+int addmntent (FILE *stream, const struct mntent *mnt);
+char *hasmntopt (const struct mntent *mnt, const char *opt);
+
+
+/* Prepare to begin reading and/or writing mount table entries from the
+   beginning of FILE.  MODE is as for `fopen'.  */
+FILE *setmntent (const char *file, const char *mode)
+{
+  /* Extend the mode parameter with "c" to disable cancellation in the
+     I/O functions and "e" to set FD_CLOEXEC.  */
+  FILE *result;
+  size_t modelen = strlen (mode);
+  char newmode[modelen + 3];
+  memcpy (newmode, mode, modelen);
+  memcpy (newmode + modelen, "ce", 3);
+  result = fopen (file, newmode);
+
+  return result;
+}
+
+
+/* Close a stream opened with `setmntent'.  */
+int endmntent (FILE *stream)
+{
+  if (stream)		/* SunOS 4.x allows for NULL stream */
+    fclose (stream);
+  return 1;		/* SunOS 4.x says to always return 1 */
+}
+
+
+/* Since the values in a line are separated by spaces, a name cannot
+   contain a space.  Therefore some programs encode spaces in names
+   by the strings "\040".  We undo the encoding when reading an entry.
+   The decoding happens in place.  */
+static char *
+decode_name (char *buf)
+{
+  char *rp = buf;
+  char *wp = buf;
+
+  do
+    if (rp[0] == '\\' && rp[1] == '0' && rp[2] == '4' && rp[3] == '0')
+      {
+	/* \040 is a SPACE.  */
+	*wp++ = ' ';
+	rp += 3;
+      }
+    else if (rp[0] == '\\' && rp[1] == '0' && rp[2] == '1' && rp[3] == '1')
+      {
+	/* \011 is a TAB.  */
+	*wp++ = '\t';
+	rp += 3;
+      }
+    else if (rp[0] == '\\' && rp[1] == '0' && rp[2] == '1' && rp[3] == '2')
+      {
+	/* \012 is a NEWLINE.  */
+	*wp++ = '\n';
+	rp += 3;
+      }
+    else if (rp[0] == '\\' && rp[1] == '\\')
+      {
+	/* We have to escape \\ to be able to represent all characters.  */
+	*wp++ = '\\';
+	rp += 1;
+      }
+    else if (rp[0] == '\\' && rp[1] == '1' && rp[2] == '3' && rp[3] == '4')
+      {
+	/* \134 is also \\.  */
+	*wp++ = '\\';
+	rp += 3;
+      }
+    else
+      *wp++ = *rp;
+  while (*rp++ != '\0');
+
+  return buf;
+}
+
+
+/* Read one mount table entry from STREAM.  Returns a pointer to storage
+   reused on the next call, or null for EOF or error (use feof/ferror to
+   check).  */
+struct mntent *getmntent_r (FILE *stream, struct mntent *mp, char *buffer, int bufsiz)
+{
+  char *cp;
+  char *head;
+
+  do
+    {
+      char *end_ptr;
+
+      if (fgets (buffer, bufsiz, stream) == NULL)
+	{
+	  return NULL;
+	}
+
+      end_ptr = strchr (buffer, '\n');
+      if (end_ptr != NULL)	/* chop newline */
+	*end_ptr = '\0';
+      else
+	{
+	  /* Not the whole line was read.  Do it now but forget it.  */
+	  char tmp[1024];
+	  while (fgets (tmp, sizeof tmp, stream) != NULL)
+	    if (strchr (tmp, '\n') != NULL)
+	      break;
+	}
+
+      head = buffer + strspn (buffer, " \t");
+      /* skip empty lines and comment lines:  */
+    }
+  while (head[0] == '\0' || head[0] == '#');
+
+  cp = strsep (&head, " \t");
+  mp->mnt_fsname = cp != NULL ? decode_name (cp) : (char *) "";
+  if (head)
+    head += strspn (head, " \t");
+  cp = strsep (&head, " \t");
+  mp->mnt_dir = cp != NULL ? decode_name (cp) : (char *) "";
+  if (head)
+    head += strspn (head, " \t");
+  cp = strsep (&head, " \t");
+  mp->mnt_type = cp != NULL ? decode_name (cp) : (char *) "";
+  if (head)
+    head += strspn (head, " \t");
+  cp = strsep (&head, " \t");
+  mp->mnt_opts = cp != NULL ? decode_name (cp) : (char *) "";
+  switch (head ? sscanf (head, " %d %d ", &mp->mnt_freq, &mp->mnt_passno) : 0)
+    {
+    case 0:
+      mp->mnt_freq = 0;
+    case 1:
+      mp->mnt_passno = 0;
+    case 2:
+      break;
+    }
+
+  return mp;
+}
+
+struct mntent *getmntent (FILE *stream)
+{
+  static struct mntent m;
+  static char *getmntent_buffer;
+
+  #define BUFFER_SIZE 4096
+  if (getmntent_buffer == NULL) {
+    getmntent_buffer = (char *) malloc (BUFFER_SIZE);
+  }
+
+  return getmntent_r (stream, &m, getmntent_buffer, BUFFER_SIZE);
+  #undef BUFFER_SIZE
+}
+
+
+/* We have to use an encoding for names if they contain spaces or tabs.
+   To be able to represent all characters we also have to escape the
+   backslash itself.  This "function" must be a macro since we use
+   `alloca'.  */
+#define encode_name(name) \
+  do {									      \
+    const char *rp = name;						      \
+									      \
+    while (*rp != '\0')							      \
+      if (*rp == ' ' || *rp == '\t' || *rp == '\n' || *rp == '\\')	      \
+	break;								      \
+      else								      \
+	++rp;								      \
+									      \
+    if (*rp != '\0')							      \
+      {									      \
+	/* In the worst case the length of the string can increase to	      \
+	   four times the current length.  */				      \
+	char *wp;							      \
+									      \
+	rp = name;							      \
+	name = wp = (char *) alloca (strlen (name) * 4 + 1);		      \
+									      \
+	do								      \
+	  if (*rp == ' ')						      \
+	    {								      \
+	      *wp++ = '\\';						      \
+	      *wp++ = '0';						      \
+	      *wp++ = '4';						      \
+	      *wp++ = '0';						      \
+	    }								      \
+	  else if (*rp == '\t')						      \
+	    {								      \
+	      *wp++ = '\\';						      \
+	      *wp++ = '0';						      \
+	      *wp++ = '1';						      \
+	      *wp++ = '1';						      \
+	    }								      \
+	  else if (*rp == '\n')						      \
+	    {								      \
+	      *wp++ = '\\';						      \
+	      *wp++ = '0';						      \
+	      *wp++ = '1';						      \
+	      *wp++ = '2';						      \
+	    }								      \
+	  else if (*rp == '\\')						      \
+	    {								      \
+	      *wp++ = '\\';						      \
+	      *wp++ = '\\';						      \
+	    }								      \
+	  else								      \
+	    *wp++ = *rp;						      \
+	while (*rp++ != '\0');						      \
+      }									      \
+  } while (0)
+
+
+/* Write the mount table entry described by MNT to STREAM.
+   Return zero on success, nonzero on failure.  */
+int addmntent (FILE *stream, const struct mntent *mnt)
+{
+  struct mntent mntcopy = *mnt;
+  if (fseek (stream, 0, SEEK_END))
+    return 1;
+
+  /* Encode spaces and tabs in the names.  */
+  encode_name (mntcopy.mnt_fsname);
+  encode_name (mntcopy.mnt_dir);
+  encode_name (mntcopy.mnt_type);
+  encode_name (mntcopy.mnt_opts);
+
+  return (fprintf (stream, "%s %s %s %s %d %d\n",
+		   mntcopy.mnt_fsname,
+		   mntcopy.mnt_dir,
+		   mntcopy.mnt_type,
+		   mntcopy.mnt_opts,
+		   mntcopy.mnt_freq,
+		   mntcopy.mnt_passno) < 0
+	  || fflush (stream) != 0);
+}
+
+
+/* Search MNT->mnt_opts for an option matching OPT.
+   Returns the address of the substring, or null if none found.  */
+char *hasmntopt (const struct mntent *mnt, const char *opt)
+{
+  const size_t optlen = strlen (opt);
+  char *rest = mnt->mnt_opts, *p;
+
+  while ((p = strstr (rest, opt)) != NULL)
+    {
+      if ((p == rest || p[-1] == ',')
+	  && (p[optlen] == '\0' || p[optlen] == '=' || p[optlen] == ','))
+	return p;
+
+      rest = strchr (p, ',');
+      if (rest == NULL)
+	break;
+      ++rest;
+    }
+
+  return NULL;
+}
diff --git a/libbb/xfuncs.c b/libbb/xfuncs.c
index 206edb4..f671a8c 100644
--- a/libbb/xfuncs.c
+++ b/libbb/xfuncs.c
@@ -181,9 +181,9 @@ char* FAST_FUNC hex2bin(char *dst, const char *str, int count)
 
 /* Return how long the file at fd is, if there's any way to determine it. */
 #ifdef UNUSED
-off_t FAST_FUNC fdlength(int fd)
+loff_t FAST_FUNC fdlength(int fd)
 {
-	off_t bottom = 0, top = 0, pos;
+	loff_t bottom = 0, top = 0, pos;
 	long size;
 
 	// If the ioctl works for this, return it.
diff --git a/libbb/xfuncs_printf.c b/libbb/xfuncs_printf.c
index 7348890..ac9efd1 100644
--- a/libbb/xfuncs_printf.c
+++ b/libbb/xfuncs_printf.c
@@ -20,6 +20,10 @@
  * xfunc_printf.c contains those which do.
  */
 
+#ifndef _LARGEFILE64_SOURCE
+/* For lseek64 */
+# define _LARGEFILE64_SOURCE
+#endif
 #include "libbb.h"
 
 
@@ -251,13 +255,13 @@ void FAST_FUNC xclose(int fd)
 }
 
 // Die with an error message if we can't lseek to the right spot.
-off_t FAST_FUNC xlseek(int fd, off_t offset, int whence)
+loff_t FAST_FUNC xlseek(int fd, loff_t offset, int whence)
 {
-	off_t off = lseek(fd, offset, whence);
-	if (off == (off_t)-1) {
+	loff_t off = lseek64(fd, offset, whence);
+	if (off == (loff_t)-1) {
 		if (whence == SEEK_SET)
-			bb_perror_msg_and_die("lseek(%"OFF_FMT"u)", offset);
-		bb_perror_msg_and_die("lseek");
+			bb_perror_msg_and_die("lseek64(%"OFF_FMT"u)", offset);
+		bb_perror_msg_and_die("lseek64");
 	}
 	return off;
 }
diff --git a/miscutils/strings.c b/miscutils/strings.c
index 9f50182..7315239 100644
--- a/miscutils/strings.c
+++ b/miscutils/strings.c
@@ -28,7 +28,7 @@ int strings_main(int argc UNUSED_PARAM, char **argv)
 {
 	int n, c, status = EXIT_SUCCESS;
 	unsigned count;
-	off_t offset;
+	loff_t offset;
 	FILE *file;
 	char *string;
 	const char *fmt = "%s: ";
diff --git a/shell/ash.c b/shell/ash.c
index b5a2d96..1d9ba4a 100644
--- a/shell/ash.c
+++ b/shell/ash.c
@@ -13125,6 +13125,7 @@ int ash_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int ash_main(int argc UNUSED_PARAM, char **argv)
 {
 	const char *shinit;
+	const char *hp;
 	volatile smallint state;
 	struct jmploc jmploc;
 	struct stackmark smark;
@@ -13185,22 +13186,13 @@ int ash_main(int argc UNUSED_PARAM, char **argv)
 	setstackmark(&smark);
 	procargs(argv);
 
-	if (argv[0] && argv[0][0] == '-')
-		isloginsh = 1;
-	if (isloginsh) {
-		const char *hp;
-
-		state = 1;
-		read_profile("/etc/profile");
+	isloginsh = 1;
+	state = 1;
+	read_profile("/system/etc/profile");
  state1:
-		state = 2;
-		hp = lookupvar("HOME");
-		if (hp) {
-			hp = concat_path_file(hp, ".profile");
-			read_profile(hp);
-			free((char*)hp);
-		}
-	}
+	state = 2;
+	if (!hp)
+		setvar("HISTFILE", "/data/ash_history", 0);
  state2:
 	state = 3;
 	if (
@@ -13230,15 +13222,10 @@ int ash_main(int argc UNUSED_PARAM, char **argv)
 	if (sflag || minusc == NULL) {
 #if MAX_HISTORY > 0 && ENABLE_FEATURE_EDITING_SAVEHISTORY
 		if (iflag) {
-			const char *hp = lookupvar("HISTFILE");
+			hp = lookupvar("HISTFILE");
 			if (!hp) {
-				hp = lookupvar("HOME");
-				if (hp) {
-					hp = concat_path_file(hp, ".ash_history");
-					setvar0("HISTFILE", hp);
-					free((char*)hp);
-					hp = lookupvar("HISTFILE");
-				}
+				setvar("HISTFILE", "/data/ash_history", 0);
+				hp = lookupvar("HISTFILE");
 			}
 			if (hp)
 				line_input_state->hist_file = hp;
diff --git a/util-linux/mkswap.c b/util-linux/mkswap.c
index b5d2c49..321881f 100644
--- a/util-linux/mkswap.c
+++ b/util-linux/mkswap.c
@@ -89,7 +89,7 @@ int mkswap_main(int argc UNUSED_PARAM, char **argv)
 {
 	int fd;
 	unsigned pagesize;
-	off_t len;
+	loff_t len;
 	const char *label = "";
 
 	opt_complementary = "-1"; /* at least one param */
